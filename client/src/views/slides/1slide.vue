<template>
    <Header/>
    <div class="mount">
    <div class="container">
      <div class="course">
        <div class="h2-header">
          <h2>Урок 1. Вступление</h2>
        </div>
        <p>Для начала - что вообще такое ООП? Ответ “Объектно-ориентированное программирование” толком не дает ответа на этот вопрос. 
            Но давайте разбираться постепенно. 
        </p>
	    <p>
          Здесь мы встречаемся с терминами “класс”, “объект”, “экземпляр”, “поле”, “методы”. Давайте разберемся на примере. 
          Допустим, создается программа по учету котов и кошек. 
          Соответственно, мы имеем дело с объектами “коты”, и было бы хорошо все данные, связанные с котами, объединить в единое целое. 
          Это можно сделать с помощью класса. Класс можно воспринимать как некий шаблон, по которому будут формироваться экземпляры - конкретные коты и кошки. 
          Так, например, у всех кошек есть порода, пол, имя и возраст. Программист сам решает, какие свойства будет иметь тот или иной класс.
        </p>
        <br>
        <div class="div__img__center">
            <img class="img__center" src="@/assets/img/firstSlide/test.jpg" alt="">
        </div>
        <p>Возьмем две кошки. Первая кошка имеет породу “Бурма”, зовут её “Васька”, и ей 3 года. 
            Вторая кошка имеет породу “Саванна”, зовут её Прелесть и ей 5 лет. 
            Говоря по-программистски, у нас 2 экземпляра класса - Васька и Прелесть, 
            у которых есть порода, имя и возраст, и они являются экземплярами класса Cats.
            И очень удобно, что мы можем работать с данными об этих кошках как с единым целым.
            Класс может описывать некий алгоритм, присущий именно этому объекту. 
            Например, можно определить метод (функцию), который бы рисовал этого кота где-либо. 
            И переиспользовать его на любом другом экземпляре (на любом другом коте или кошке).
        </p>
        <p>
            Например, для того, чтобы изменить размер, указанный в нашем классе, мы можем написать Point.size = 3, 
            и теперь по умолчанию атрибут size будет равен 3. 
            Для того, что увидеть все переменные класса, нам нужно прописать Point.__dict__.
            Прописав её, мы видим много всяких атрибутов, и среди них мы можем увидеть color и size.
            Давайте теперь создадим экземпляр нашего класса.
            Для этого нам нужно указать название нашего экземпляра и “вызвать” класс.
            Пример - “a = Point()”.
        </p>
        <p>
            Для того, чтобы узнать к какому классу принадлежит какая-либо переменная или же экземпляр класса, мы можем написать “type(a)”, 
            и в нашем случае получим class ‘__main__.Point’. 
            Таким образом мы наглядно видим, что переменная “а” является экземпляром класса Point.
        </p>
        <p>
            Также мы можем проверить, является ли переменная экземпляром какого-то конкретного класса при помощи “type(a) == Point”. 
            На выходе мы получаем true, так что да, “а” является экземпляром класса Point.
        </p>
        <p>
            Ну и для полноты картины, чтобы проверить является ли “а” экземпляром класса Point, мы можем написать “isinstance(a, Point)”, 
            и также на выходе получаем true.
	        То есть имя класса выступает в качестве типа данных, как, например, int, float, boolean и др.
        </p>
        <p>
            По сути, при создании экземпляров, они образуют свое пространство имен, и если мы поменяем, например, 
            у экземпляра a значение атрибута color - то цвет изменится только у а, 
            и никак не затронет b или значение по умолчанию, указанное в классе Point.
        </p>
        <p>
            Мы можем прямо в коде добавлять новые атрибуты при помощи setattr. 
            Пишем setattr, открываем круглые скобки, пишем название класса, затем название нового атрибута, и затем значение. 
            Так, мы можем прописать setattr(Point, “type”, “vector”), и теперь у всех экземпляров класса появится новый атрибут type, 
            и значением по умолчанию будет “vector”. 
        </p>
        <p>
            Помимо этого, через setattr мы можем поменять значение уже существующего атрибута. 
            И если мы напишем setattr(Point, ‘size’, 14), мы в классе Point поставим значение по умолчанию 14. 
        </p>
        <p>
            Ещё мы можем получить данные из класса при помощи Point.size, но что будет, если мы укажем несуществующий атрибут? 
            Например, Point.date? Мы получим исключение, но этого можно избежать при помощи getattr. 
            И если мы пропишем getattr(Point, date), то мы все равно получим ошибку. Но если мы добавим третий аргумент, 
            и у нас получится getattr(Point, ‘date’, False), то третий аргумент будет возвращаться, 
            если указанный аргумент (на второй позиции) не существует. Ну а если мы укажем существующий аргумент 
            (getattr(Point, ‘size’, False)), то нам вернется значение size.
        </p>
        <p>
            А ещё мы можем удалять атрибуты из класса. Допустим, мы хотим удалить атрибут color.
            Пишем del Point.size, и у нас удаляется этот атрибут. 
            С этим стоит быть аккуратнее, поскольку если мы удалим несуществующий атрибут, то получим необрабатываемое исключение, 
            и с этим стоит быть аккуратнее.
        </p>
        <p>
            Для того, чтобы проверить, существует ли какой-либо атрибут, мы можем использовать hasattr. 
            Например, hasattr(Point, ‘color’) вернет нам True, потому что color существует в нашем классе Point.
        </p>
        <p>
            Если мы попытаемся удалить у “a” атрибут “color”, то он поменяется на тот, что по умолчанию прописан в классе Point. 
            То бишь “color” у “a” станет “black”. 
            А при попытке удалить size из экземпляра a, мы получим исключение, поскольку “size” в “a” НЕ переопределен, 
            и его как бы не существует в самом “a”.
        </p>
        <p>
            Поиск того или иного атрибута выполняется следующим образом - сначала ведется поиск в текущем пространстве имен 
            (например, в экземпляре “a”), а если не находит, то ведется поиск во внешнем пространстве имен.
        </p>
        <div class="form-btns">
          <form action="/courses">
          <button>Назад</button>
          </form>
          <form action="/2slide">
            <button>Далее</button>
          </form>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
    import Header from "@/components/Header.vue";
    export default {
      name: 'CoursesView',
      components: {
          Header,
      },
    };
</script>

<style lang="scss" scoped>
@import "@/assets/css/slides.scss";
</style>