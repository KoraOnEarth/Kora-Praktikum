<template>
    <Header/>
    <div class="mount">
    <div class="container">
      <div class="course">
        <div class="h2-header">
          <h2>Урок 4. Магический метод __new__</h2>
        </div>
        <p>
            Я обещал рассказать про метод __new__, и считаю, что настало время.
            Подготовил небольшую заготовку для лучшего объяснения.
        </p>
        <p>
            Здесь мы можем увидеть новую переменную - cls.
            Её отличие от self в том, что последняя ссылается на экземпляр класса, а cls - на сам класс.
        </p>
        <p>
            Теперь создадим экземпляр класса и увидим, что у нас вызвался __new__, но не вызвался наш инициализатор. 
            Мы можем в этом убедиться, если выведем через print наш экземпляр, и получим None, 
            что говорит о том, что экземпляр не был создан.
            Что же случилось и почему у нас так странно все отработало?
            Дело в том, что метод __new__ должен возвращать адрес нового созданного объекта. 
            Давайте вернем этот адрес, но где нам его взять?
            Давайте обратимся к базовому классу super(), и вызовем в нём метод __new__, передав cls. 
            У нас получится return super().__new__(cls).
        </p>
        <p>
            Но что за базовый класс такой, из которого мы вызываем магический метод __new__?
            Ведь наш класс Point определен сам по себе, и других классов тут нет. 
            На самом деле, мы не проходили ещё наследование, но стоит понять, 
            что все классы в Python наследуются от класса object, 
            и у этого базового класса мы и вызываем метод __new__.
        </p>
        <p>
            Если мы запустим наш код с модифицированным return, то уже увидим изменения. 
            У нас был вызван метод __new__, и затем все корректно проинициализировалось.
        </p>
        <p>
            Остается главный вопрос - зачем нам вообще это нужно? 
            Для ответа на этот вопрос я приведу пример одного из очень популярных паттернов проектирования - Singleton.
            Давайте представим, что мы разрабатываем некий класс для работы с базой данных. 
            И далее полагаем, что у нас в программе должен существовать только один экземпляр этого класса. 
            То есть когда мы создаем экземпляр класса БД и передаем в неё данные, то у нас создается этот экземпляр. 
            Но на протяжении работы программы у нас этот экземпляр должен быть только один. 
            И если мы создадим второй экземпляр БД, то ссылка должна вести на уже созданный экземпляр.
        </p>
        <p>
            Разберемся на этом коде:
        </p>
        <p>
            И вот экземпляр этого класса должен существовать только один.
            Для этого пропишем в начале реализации класса __instance = None.
            Этот instance будет держать в себе ссылку на экземпляр класса. 
            Соответственно, если у нас нет созданного экземпляра класса, то в __instance будет храниться None, 
            а если есть - в __instance будет храниться ссылка на экземпляр. 
            Таким образом мы можем контролировать, существует ли объект данного класса или нет. 
            И далее для управления созданием экземпляров, нам нужно переопределить этот магический метод __new__.
            В этом методе проверим атрибут __instance. 
            Если он None, то мы присвоим адрес вот этого нового объекта. А ниже вернем этот атрибут __instance.
        </p>
        <p>
            Получается, что мы проверяем, записан ли адрес в __instance. 
            Если его нет - то мы обновляем значение __instance, а если есть - то просто возвращаем этот адрес. 
            Так мы проверяем, что у нас в программе существует ровно один объект нашего класса DataBase.
            Ну и по-хорошему, нам нужно прописать финализатор, в котором __instance вернем значение None.
        </p>
        <p>
            Теперь давайте проверим работу того, что мы сделали.
            Создадим экземпляр db, и сразу ещё один, немного подредактировав значения.
            И через print() выведем id этих объектов. 
            Если они ссылаются на один и тот же экземпляр - значит у нас только один объект, 
            а второй не был создан. Как мы можем убедиться, все так и есть.
        </p>
        <p>
            У нашей реализации есть один недостаток - если мы проверим что записано в нашем экземпляре, 
            то увидим, что у нас записаны данные последней инициализации объекта. 
            Для того, чтобы это поправить, нам нужно использовать магический метод __call__, 
            но пока мы до него не добрались, давайте оставим все как есть.
        </p>
        <div class="form-btns">
          <form action="/3slide">
            <button>Назад</button>
          </form>
          <form action="/5slide">
            <button>Далее</button>
          </form>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
    import Header from "@/components/Header.vue";
    export default {
      name: 'CoursesView',
      components: {
          Header,
      },
    };
</script>

<style lang="scss" scoped>
@import "@/assets/css/slides.scss";
</style>