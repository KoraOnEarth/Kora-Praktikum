<template>
    <Header/>
    <div class="mount">
    <div class="container">
      <div class="course">
        <div class="h2-header">
          <h2>Урок 4. Магический метод __new__</h2>
        </div>
        <p>
            Я обещал рассказать про метод <strong>__new__</strong>, и считаю, что настало время.
            Подготовил небольшую заготовку для лучшего объяснения.
        </p>
        <div class="div__img__center">
            <img class="img__center" src="@/assets/img/fourthSlide/1.png" alt="">
        </div>
        <p>
            Здесь мы можем увидеть новую переменную - <strong>cls</strong>.
            Её отличие от self в том, что последняя ссылается на <strong>экземпляр</strong> класса, а cls - на <strong>сам класс</strong>.
        </p>
        <p>
            Теперь создадим <strong>экземпляр</strong> класса и увидим, что у нас вызвался __new__, но не вызвался наш инициализатор. 
            Мы можем в этом убедиться, если выведем через print наш экземпляр, и получим None, 
            что говорит о том, что экземпляр не был создан.
            Что же случилось и почему у нас так странно все отработало?
            Дело в том, что метод __new__ <strong>должен возвращать адрес нового созданного объекта</strong>. 
            Давайте вернем этот адрес, но где нам его взять?
            Обратимся к базовому классу super(), и вызовем в нём метод __new__, передав cls. 
            У нас получится <strong>return super().__new__(cls)</strong>.
        </p>
        <div class="div__img__center">
            <img class="img__center" src="@/assets/img/fourthSlide/2.png" alt="">
        </div>
        <p>
            Но что за <strong>базовый</strong> класс такой, из которого мы вызываем магический метод __new__?
            Ведь наш класс Point определен сам по себе, и других классов тут нет. 
            На самом деле, мы не проходили ещё наследование, но стоит понять, 
            что <strong>все классы в Python наследуются от класса object</strong>, 
            и у этого базового класса мы и вызываем метод __new__.
        </p>
        <p>
            Если мы запустим наш код с модифицированным return, то уже увидим изменения. 
            У нас был вызван метод __new__, и затем все корректно проинициализировалось.
        </p>
        <p>
            Остается главный вопрос - <strong>зачем нам вообще это нужно</strong>? 
            Для ответа на этот вопрос я приведу пример одного из очень популярных паттернов проектирования - <strong>Singleton</strong>.
            Давайте представим, что мы разрабатываем <strong>некий класс для работы с базой данных</strong>. 
            И далее полагаем, что у нас в программе должен существовать только <strong>один</strong> экземпляр этого класса. 
            То есть когда мы создаем экземпляр класса БД и передаем в неё данные, то у нас создается этот экземпляр. 
            Но на протяжении работы программы у нас этот экземпляр должен быть только один. 
            <strong>И если мы создадим второй экземпляр БД, то ссылка должна вести на уже созданный экземпляр</strong>.
        </p>
        <p>
            Разберемся на этом коде:
        </p>
        <div class="div__img__center">
            <img class="img__center" src="@/assets/img/fourthSlide/3.png" alt="">
        </div>
        <p>
            И вот экземпляр этого класса должен существовать только один.
            Для этого пропишем в начале реализации класса __instance = None.
            Этот instance будет держать в себе ссылку на экземпляр класса. 
            Соответственно, если у нас нет созданного экземпляра класса, то в __instance будет храниться None, 
            а если есть - в __instance будет храниться ссылка на экземпляр. 
            Таким образом мы можем контролировать, существует ли объект данного класса или нет. 
            И далее для управления созданием экземпляров, нам нужно переопределить этот магический метод __new__.
            В этом методе проверим атрибут __instance. 
            Если он None, то мы присвоим адрес вот этого нового объекта. А ниже вернем этот атрибут __instance.
        </p>
        <p>
            Получается, что мы проверяем, записан ли адрес в __instance. 
            Если его нет - то мы обновляем значение __instance, а если есть - то просто возвращаем этот адрес. 
            Так мы проверяем, что у нас в программе существует ровно один объект нашего класса DataBase.
            Ну и по-хорошему, нам нужно прописать финализатор, в котором __instance вернем значение None.
        </p>
        <div class="div__img__center">
            <img class="img__center" src="@/assets/img/fourthSlide/4.png" alt="">
        </div>
        <p>
            Теперь давайте проверим работу того, что мы сделали.
            Создадим экземпляр db, и сразу ещё один, немного подредактировав значения.
            И через print() выведем id этих объектов. 
            Если они ссылаются на один и тот же экземпляр - значит у нас только один объект, 
            а второй не был создан. Как мы можем убедиться, все так и есть.
        </p>
        <p>
            У нашей реализации есть один недостаток - если мы проверим что записано в нашем экземпляре, 
            то увидим, что у нас записаны данные последней инициализации объекта. 
            Для того, чтобы это поправить, нам нужно использовать магический метод __call__, 
            но пока мы до него не добрались, давайте оставим все как есть.
        </p>
        <div class="div__img__center">
            <img class="img__center" src="@/assets/img/fourthSlide/5.png" alt="">
        </div>
        <div class="form-btns">
          <form action="/3slide">
            <button>Назад</button>
          </form>
          <form action="/5slide">
            <button>Далее</button>
          </form>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
    import Header from "@/components/Header.vue";
    export default {
      name: 'CoursesView',
      components: {
          Header,
      },
    };
</script>

<style lang="scss" scoped>
@import "@/assets/css/slides.scss";
</style>